/* 演習12-01
 * 前置演算子関数から後置演算子関数を呼び出して書き換え、逆も行いどちらのほうが好ましいか検討
 * 作成日：5月23日
 * 作成者：成田修之
 */

//インクルードガード
#ifndef ___Class_Counter
#define ___Class_Counter

#include<climits>

//カウンタクラス
class Counter {
	//データメンバ
	unsigned cnt;
public:

	//引数を受け取らないデフォルトインストラクタ：0で初期化
	Counter():cnt(0){}
	//変換関数
	operator unsigned() const {
		//データメンバを返却
		return cnt;
	}
	//論理演算子！についての演算子関数
	bool operator!() const {
		//クラス中のカウンタが0ならTrueを0でないならFalseを返却する
		return cnt == 0;
	}

	//前置演算子関数
	Counter& operator++() {
		//カウンタが最大より低いとき
		if(cnt < UINT_MAX) {
			//カウンタをインクリメントする
			cnt++;
		}
		//インクリメントされたオブジェクト自体への参照を返却
		return *this;
	}

	//後置演算子関数を前置演算子関数を呼び出して作成
	Counter operator++(int) {
		//インクリメントされる前のカウンタを別のオブジェクトに避難させる
		Counter x = *this;
		//前置演算子関数を呼び出してカウンタをインクリメント
		Counter::operator++();
		//避難させてあったインクリメントされる前のカウンタを返却
		return x;
	}

	//後置演算子関数
	Counter operator--(int) {
		//デクリメントされる前のカウンタを別のオブジェクトに避難させる
		Counter x = *this;
		//カウンタが0より大きいとき
		if(cnt > 0) {
			//デクリメントする
			cnt--;
		}
		//避難してあったデクリメントされる前のカウンタを返却
		return x;
	}

	//前置演算子関数を後置演算子関数を呼び出して作成
	Counter& operator--() {
		//後置演算子関数を呼び出してカウンタをデクリメント
		Counter::operator--(0);
		//デクリメントされたカウンタ自身への参照を返却
		return *this;
	}
};

//インクルードガードの定義の終わり
#endif

/* 結果：前置演算子関数を後置演算子関数を呼び出して作成する場合には後置演算を行った後の
 * 		オブジェクトの要素を返却すればいいだけだが、後置演算子を前置演算子関数を
 * 		呼び出しての作成となるとどうしても一つ新たなオブジェクトが必要になるので
 * 		前置と後置では前置演算子関数のほうが効率よく行うことが出来る点で望ましいと思われる
 */
